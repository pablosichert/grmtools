initSidebarItems({"enum":[["LexParseError","A lexing or parsing error. Although the two are quite distinct in terms of what can be reported to users, both can (at least conceptually) occur at any point of the intertwined lexing/parsing process."],["Node","A generic parse tree."],["ParseRepair","After a parse error is encountered, the parser attempts to find a way of recovering. Each entry in the sequence of repairs is represented by a `ParseRepair`."],["RecoveryKind","What recovery algorithm should be used when a syntax error is encountered?"]],"macro":[["lrpar_mod","A convenience macro for including statically compiled `.y` files. A file `src/x.y` which is statically compiled by lrpar can then be used in a crate with `lrpar_mod!(x)`."]],"struct":[["CTParserBuilder","A `CTParserBuilder` allows one to specify the criteria for building a statically generated parser."],["LexError","A Lexing error."],["Lexeme","A `Lexeme` represents a segment of the user's input that conforms to a known type. All lexemes have a starting position in the user's input: lexemes that result from error recovery, however, do not have a length (or, therefore, an end). This allows us to differentiate between lexemes that are always of zero length (which are required in some grammars) from lexemes that result from error recovery (where an error recovery algorithm can know the type that a lexeme should have been, but can't know what its contents should have been)."],["ParseError","Records a single parse error."],["RTParserBuilder","A run-time parser builder."]],"trait":[["Lexer","Roughly speaking, `Lexer` is an iterator which collectively produces `Lexeme`s, as well as collecting the newlines encountered so that it can later optionally answer queries of the form \"what's the line and column number of lexeme L\"."]]});